<!DOCTYPE html>
<input type="file" name="file" id="file">
<meta charset="utf-8">
  <style>
    .land {
      fill: #ccc;
    }

    .border {
      fill: none;
      stroke: #fff;
      stroke-linejoin: round;
      stroke-linecap: round;
    }

    circle {
      fill: #013243;
      fill-opacity: .6;
      stroke: white;
    }
  </style>
  <head>
    <link rel="stylesheet" href="style2.css">
  </head>
  <body>
    <div class = "tag">
      <a class="tag0">sharepoint</a>
      <a class="tag0">web services</a>
      <a class="tag0">apache rave</a>
      <a class="tag0">html</a>
      <a class="tag0">spring framework</a>
      <a class="tag0">scrum</a>
      <a class="tag0">c#</a>
      <a class="tag0">certified scrum master</a>
      <a class="tag0">rest</a>
      <a class="tag0">enterprise search</a>
      <a class="tag0">web applications</a>
      <a class="tag0">css</a>
      <a class="tag0">java</a>
      <a class="tag0">jquery</a>
      <a class="tag0">agile</a>
      <a class="tag0">agile development</a>
      <a class="tag0">xml</a>
      <a class="tag0">javascript</a>
      <a class="tag0">testing</a>
      <a class="tag0">project management</a>
    </div>
    <div id="tagZone" class="tag"></div>
    <ul id="selectedTags" class="sList"></ul>
    <script type="text/javascript" src="tagButtons.js"></script>
    <input type="button" value="Clear Selected" src="tagButtons.js" onclick="ClearSelected()"/>


    <script src="//d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src="//d3js.org/topojson.v1.min.js"></script>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>
    <script>
      // the testTags variable is a global variable that will be modified when a user
      // uploads a file
      let testTags = [];
      var total = 10;
      var datSet = [];
      var zoomSet = [];
      const CreateTagList = (data) => {
        // the nested array var takes all the tags from the data and splits by the
        // delimiter and returns a nested array
        const nestedArray = data.map(company => {
          return company.tags.split(':')
        })

        // iterate over nested array to flatten
        const flattenedArray = []
        for(let i = 0; i < nestedArray.length; i += 1) {
          for(let j = 0; j < nestedArray[i].length; j += 1) {
            flattenedArray.push(nestedArray[i][j])
          }
        }

        // only get the unique values using the filter function (method defined below)
        // could also do this in a traditional way with for-loop and push only values
        // that haven't been seen before to the array
        testTags = flattenedArray.filter(onlyUnique)
        return testTags
      }

      const onlyUnique = (value, index, self) => {
        return self.indexOf(value) === index;
      }

      var tagDiv = document.getElementById("tagZone");
      var selectedList = document.getElementById("selectedTags");
      var selected = [];

      var blank = d3.select("body")
                    .append("svg")
                    .attr("width", 100)
                    .attr("height", 100);

      var fillblank = d3.select("blank").append("testTags");

      function GetRandomColor() {
        var r = (Math.floor(Math.random() * 256));
        var g = (Math.floor(Math.random() * 256));
        var b = (Math.floor(Math.random() * 256));
        return 'rgb(' + r + ',' + g + ',' + b + ')';
      }

      // Viz parameters
      const width = 960
      const height = 600


      // *********************************************
      // These projections are for the data in the csv file that will eventually be uploadable
      // *********************************************
      var projectionCSV = d3.geo.albersUsa()
        .scale(1280)
        .translate([width / 2, height / 2])
        .precision(.5);



      var pathCSV = d3.geo.path()
          .projection(projectionCSV)

      // *********************************************
      // These projections are for drawing the actual map and state lines
      // *********************************************
      var zoom = d3.behavior.zoom()
      .scaleExtent([.5, 100])
      .on("zoom", zoomed);

      var path = d3.geo.path()
          .projection(null);

      var svg = d3.select("body").append("svg")
          .attr("width", width)
          .attr("height", height)
        .append("g");

      var g = svg.append("g");

     svg
      .call(zoom)
      .call(zoom.event);



      var radius = d3.scale.sqrt()
          .domain([0, 1e6])
          .range([0, 15]);
      // Define the div for the tooltip
      var div = d3.select("body").append("div")
          .attr("class", "tooltip")
          .style("opacity", 0);

      // This is the code that project the united states with state lines
      d3.json("/us.json", function(error, us) {
        if (error) return console.error(error);

        g.append("path")
          .datum(topojson.feature(us, us.objects.states))
          .attr("class", "land")
          .attr("d", path);

          g.append("path")
            .datum(topojson.mesh(us, us.objects.states, function(a, b) { return a !== b; }))
            .attr("class", "border border--state")
            .attr("d", path);
      });

      // this is the code that projects the lat/longs for individual companies
      // when you allow upload functionality this function will be working on the file that was uploaded
      const drawCompanies = () => {

        //Select file on page
        document.getElementById('file').onchange = function(){
          var file = this.files[0];
          var data_file = file['name'];


        d3.csv(data_file, (err, companies) => {
            if(err) {
              return console.log(err)
            } else {

              //capture datSet for redraw
              datSet = companies.slice();

              // Draw the buttons here so that the points on the map and the buttons are created all at once
              CreateTagList(companies)
              ConstructButtons(testTags)

              g.append('path')
                .attr('class', 'companies')
                .attr('d', pathCSV);

              g.selectAll('circle')
                .attr('class', 'companies')
                .data(companies)
                .enter()
                .append('circle')
                .attr("id","path")
                .attr('transform', (d) => {

                  return `translate(${projectionCSV([d.lng, d.lat])})`

                })
                .attr('r', (d) => {
                  return 0;
                })

                //tooltip functionality
                .on("mouseover", function(d) {
                    div.transition()
                        .duration(200)
                        .style("opacity", .9);
                    div	.html(`<p>Customer Name: ${d.customer_name}</p>
                              <p>Contact Name: ${d.contact_name}</p>`)
                        .attr("left", (d3.event.pageX) + "px")
                        .attr("top", (d3.event.pageY - 28) + "px");
                    })
                .on("mouseout", function(d) {
                    div.transition()
                        .duration(500)
                        .style("opacity", 0);
                });
            }
        })
      }
    }
    function updateView() {
        redrawCities();
    }

    function redrawCities(){

                zoomSet = datSet.slice(0);

                cluster();


                g.selectAll('circle').remove();

                g.selectAll('circle')
                .attr('class', 'companies')
                .data(zoomSet)

                .enter()
                .append('circle')
                .attr('transform', (d) => {
                  return `translate(${projectionCSV([d.lng, d.lat])})`
                })

                .attr('r', (d) => {
                    var  tags1 = d.tags.split(":");
                    for(var tagSelected in tagArray){
                      for(var tagPresent in tags1){
                        if (tagArray[tagSelected] == tags1[tagPresent]) {

                          return 10/zoom.scale();

                        }
                      }
                    }
                    return 0;
                  })
                  .style("stroke-width", 1/zoom.scale())
                  .on("mouseover", function(d) {
                      div.transition()
                          .duration(200)
                          .style("opacity", .9);
                      div	.html(`<p>Customer Name: ${d.customer_name}</p>
                                <p>Contact Name: ${d.contact_name}</p>`)
                          .attr("left", (d3.event.pageX) + "px")
                          .attr("top", (d3.event.pageY - 28) + "px");
                      })
                  .on("mouseout", function(d) {
                      div.transition()
                          .duration(500)
                          .style("opacity", 0);
                  });




      }

    function zoomed() {

        redrawCities();

        g.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");


    }
    function cluster() {
      var flag = false


      for(i = 0; i < zoomSet.length; i++){
        for(j = i+1; j < zoomSet.length; j++){
          for(k = 0; k<tagArray.length; k++){
            if(zoomSet[i].tags.includes(tagArray[k]) && zoomSet[j].tags.includes(tagArray[k])){

              if(Math.abs(zoomSet[i].lat - zoomSet[j].lat) < 1/zoom.scale() && Math.abs(zoomSet[i].lng - zoomSet[j].lng) < 1/zoom.scale()){
                var flag = true
                zoomSet[i] = {contact_name: zoomSet[i].contact_name + ", " + zoomSet[j].contact_name, customer_name:zoomSet[i].customer_name + ", " + zoomSet[j].customer_name, lat:String((parseFloat(zoomSet[i].lat) + parseFloat(zoomSet[j].lat))/2), lng:String((parseFloat(zoomSet[i].lng) + parseFloat(zoomSet[j].lng))/2), tags:zoomSet[i].tags + ":" + zoomSet[j].tags}
                zoomSet.splice(j,1);
            }
          }
          }
        }
      }

      if(flag == true){
        cluster()
      }
      else {
        return
      }
    }

      // we have to set a timeout on when we draw the circles because otherwise the cirlces will be drawn before the map
      // and then the map will cover the circles. So, we need to make sure that the circles aren't drawn until after the map.
      const timeout1 = setTimeout(() => {
        drawCompanies()

      }, 1000)


    </script>
  </body>
